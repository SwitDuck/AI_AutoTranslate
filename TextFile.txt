ebooks for free more visit httillalialukhtar blogspotcom
arm developers guide system elseviek and designing optimizing system software s sloss andrw n symes dominic chris wright miks
arm developers guide system designing optimizing and system software
about authors the andrew sloss n andrew sloss received computer science from the university of herefordshire uk bsc in a 1992 and certified chartered the british computer society cca mbcs in engineer by eng was as a has worked in industry for and has involved the he the 16 been with arm computer over years 1987 has gained developing wide of applications since he extensive experience processor range a running arm designed the first editing for both chinese and the he egyptian processor systems on hieroglyphics the and arm3 for emerald publishing uk andrew executing arm2 on processors sloss has worked arm inc for technical sales advising six he is currently engineer at over years a and developing products within the us sales supporting companies he works organization new california and is based los gatos in symes dominic software ltd cambridge england dominic symes is currently engineer arm in where at a worked armbased embedded his he has software since 1995 he received ba and de phil in on mathematics from oxford university first programmed and he the arm in 1989 is particularly algorithms and techniques before interested in optimization joining arm he commercial and wrote public domain softwares arm chris wright embedded lockheed chris wright began his in the early 80s advanced marine systems career at systems while advanced marine systems he small software control for systems at wrote use on of of his the intel 8051 family microcontrollers he has much working the lockheed spent at career palo alto research laboratory and software development dow telerate most in jones group at a recently chris wright the customer support training and several in arm incs spent years at group developing supporting companies armbased products chris wright currently the partner is new ultimodule director of customer support inc in sunnyvale california at john rayfeld john rayfeld independent consultant formerly vice president of marketing uss an at was arm this role he responsible for setting arms marketing direction the uss in strategic in was and identifying opportunities for technologies market joined arm key john to segmentss new serve within in 1996 and held roles the including director of technical marketing and various company which reds focused around productechnology development before joining arm john were new held feld of digital several engineering and roles in the signal processing software management hardware asic and design john holds msc signal from the university of in processing system an and surrey uk b sc hons in electronic engineering from brunel university uks a
arm system developers guide designing optimizing and system software sloss andrew ne dominic symes chris wright with john rayfield contribution by a amsterdam boston heidel berg london me new york oxford paris san diego san francisco singapore sydney tokyo elsevier morgan kaufmann publishers morgan kaufmann of elsevier 1s an imprint
senior editor em denise penrose publishing services manager simon crump project sarah m hajduk manager editor belinda developmental breyer editorial assistant summer block cover design dick hannus cover image red wing no6 by charles biederman collection walker art center minneapolis gift of the ford foundation purchase artist through the program 1964 publishing technical illustration dartmouth composition cepha imaging ltd copyeditor ken dellapenta proofreader cocker jan indexer ferreira indexing interior the maple vail manufacturing group printer book cover phoenix color printer publishers of elsevier morgan kaufmann is imprint an 500 sansome street suite 400 san franciscos ca 941 1i this book is printed acid free paper on by 2004 elsevier inc all rights reserved the examples and applications presented in this book and the publisher web site have been included or their instructional programs s on the publisher and the authors offer implied including but limited implied warranties of fitness merchantability value not to no warranty or express or liability information for particular and do for loss damage arising rom the of this book not accept uise in any purpose any any or any or any crror or omission such informations incorrect of these proceduress and applications in or any use programs designations used by companies distinguish their products often claimed trademarks registered trademarks all to in instances in are ds or which kaufmann publishers of readers should morgan ls claim the product in initial capital all capital letters however aware a names appear or the appropriate for complete information regarding trademarks and registration contact companies more no of this publication be reproduced stored in retrieval transmitted in orm by electronic mechanical part system may a or any or any means of publisher photocopying scanning otherwise without prior written permission the or technology permissions be sought directly from elsevier science 8x rights department in oxford uks phone 444 1865 848830 faxs s may email you elsevier ta4 1865 8533335 permissionselsevien uk also complete online via the homepage chtpilleviencom by com may your request obtaining selecting customer support and then permissions of inpublication library congress cataloging data sloss andrew n guider designing softwarelandrew arm developers and optimizing n system system sloss dominic symes chris wright p cime includes bibliographical references index and isbn 155860 8745 lalk paper softwares risc microprocessors computer l computer development 2 3 architecture l symes dominic wright chris 1953 iil title il qa7676d47s565 2004 005 ede22 2004040366 isbn 155s608745 for information kaufmann publications all morgan on visit web site mkp our at www com printed in the united states of america 08 07 06 05 04 5 4 3 2 l
contents li about authors the xi preface chapter l arm embedded systems 35 the risc philosophy 11 design 4 the arm philosophy 5 12 design embedded 13 system hardware 6 embedded system software 14 12 summary 15 15 chapter 2 arm fundamentals 19 processor 2 registers 21 l status 22 current program register 22 pipeline 23 29 and the table 24 exceptions interrupts vector 33 25 5 core extensions 34 architecture revisions 25 6 37 arm processor families 27 38 28 summary 45 chapter 3 47 introduction arm instruction set to the data processing instructions 50 31 branch instructions 32 58 load store instructions 33 60 34 software interrupt instruction 73 program status instructions 31 5 register 75 31 loading constants 78 6 37 armvse extensions 79 conditional 38 execution 82 34 summary 84 9
vi contents chapter 4 thumb 87 introduction the instruction set to thumb 4l register usage 89 42 arm thumb interworking 90 other branch instructions 4 3 92 processing instructions 44 data 93 load 45 singleregister store instructions 96 load multipleregister store instructions 97 46 47 stack instructions 98 software interrupt instruction 48 99 summary 4 9 100 chapter 5 103 efficient c programming of c compilers and optimization 5 overview 104 l basic c data types 105 52 5 clooping structures 113 3 register allocation 120 54 4 calls 55 function 122 5 pointer aliasing 127 6 structure arrangement 130 5 z bitfelds 54 8 133 unaligned and endianness 5 9 data 136 10 division 58 140 floating point 149 5 11 inline and inline assembly 51 12 functions 149 portability 13 issues 5 155 summary 5 14 155 chapter 6 157 writing optimizing arm assembly code and writing assembly code 6 158 l profiling and cycle 6 2 counting 163 scheduling 63 instruction 165 register allocation 171 64 conditional execution 6 5 180 constructs 183 6 6 looping manipulation 6 7 bit 191 efficient switches 197 6 8
vii contents handling unaligned data 201 6 9 610 summary 204 chapter t 207 optimized primitives doubleprecision integer multiplication 71 208 normalization and count leading zeros 72 integer 212 73 division 216 74 square roots 238 7 transcendental functionst log 5 sin 241 cos exp and 76 endian reversal bit operations 248 saturated and rounded arithmetic 77 253 random number 78 generation 255 79 summary 256 chapter 8 digital 259 signal processing digital signal 8 representing 260 l a introduction 82 dsp the arm 269 to on filters 83 fir 280 ir filters 294 84 the discrete fourier transform 303 84 5 86 summary 314 chapter 9 exception 317 interrupt handling and handling 9 exception 318 l interrupts 92 324 handling schemes 93 interrupt 333 summary 364 9 4 chapter 10 firmware 367 firmware and bootloader 10 367 l sandstone 102 example 372 103 summary 379
vii contents chapter 11 381 embedded operating systems fundamental components 111 381 simple 112 example little operating system 383 summary 113 400 chapter 12 caches 403 the memory hierarchy and cache memory 125 1 404 cache architecture 122 408 123 cache policy 418 coprocessor and caches 12 4 15 423 flushing and cleaning cache 125 5 memory 423 cache lockdown 12 6 4453 caches and software performance 12 7 456 128 summary 457 chapter 13 461 memory protection units protected 13 regions 463 l and buffer 132 initializing the mpu caches write 465 of mpu 133 demonstration 478 an system 13 a4 summary 487 chapter 14 491 memory management units 141 moving from mpu mmu 492 an to an 142 virtual memory works 493 how of the mmu 143 details arm 501 tables 144 page 501 lookaside buffer the translation 506 145 146 domains and memory access permission 510 buffer 147 the caches and write 512 and mmu configuration 148 coprocessor 15 513 149 the fast context switch extension 515 14 10 demonstration small virtual memory system 520 a 1411 the mmuslos demonstration 545 as 12 14 summary 545
ix contents chapter 15 the future architecture of the 549 john rayfield by advanced and 15 dsp simd support armv6 550 1 in and additions armv6 157 2 system multiprocessor support 560 to 153 armv6 implementations 563 beyond future technologies armv6 155 4 563 155 summary 566 appendix a 569 arm thumb assembler instructions and this appendix al using 569 a2 syntax 570 alphabetical list of arm and thumb a3 instructions 573 assembler reference a4 arm quick 620 gnu assembler quick reference a 5 631 appendix b thumb encodings 637 arm instruction and encodings b arm instruction set 637 l thumb instruction set encodings b2 638 b3 program status registers 645 appendix c processors 647 and architecture cal arm naming convention 647 and architectures c2 core 647 appendix d cycle timings 651 instruction using the instruction cycle timing tables 651 ds l armztdmi instruction cycle timings 653 da 2 armitdmi instruction cycle timings d3 654 strongarmi instruction cycle timings 655 d 4 armie cycle timings d 5 instruction 656 armioe cycle timings ds instruction 658 6 intel xscale instruction cycle timings de z 659 timings d armil cycle 66l 8
contents appendix e 667 suggested reading references arm e 667 l algorithm references e2 667 and cache architecture hardware es management overview 3 memory and reference 667 references es 4 operating system 668 669 index
preface embedded and designers specific increasingly developers systemonchip select systems offtheshelf microprocessor and family of tools libraries and cores components to a industry quickly develop microprocessor based products major this a player in is new architecture 32bit arm over the last 10 the arm has become the pervasive years most architecture the world than billion based shipped in with 2 armi the at more processors of this writing arm embedded products from cellmobile time in ranging processors are worldwide of phones automotive braking community arm and to systems a partners thirds vendors has developed semiconductor and product design companiess party among including hardware designers and software developers to date book engineers system no addressed develop and has directly their need the software for armbased to system an embedded design this fills that text gap ofthe our goal has been describe the operation arm from product developer to core s a emphasis software specifically perspective with clear because have written this book a on we for who experienced with embedded development but engineers who be systems are may unfamiliar with the arm architecture assumed have previous arm experience we no help readers become productive quickly possible included to have suite our as as we a of arm software integrated products used examples that be into commercial can or as templates for the quick of productive software the numbered creation examples are so readers that easily locate the code the publisher web site the examples can source on s are valuable with design efficient also people arm experience who make the to want to most of embedded armbased system use an organization book the of discussing the book begins bybriefly the arm design philosophy and how noting processor differs from traditional and why it the risc philosophy the frst chapter also introduces a embedded simple based the arm system on processor chapter 2 digs deeply the hardware focusing the arm and into more on processor core of presenting overview the arm currently in the marketplace an cores the and thumb focus of and arm instruction the chapters 5 4 respectivelys sets are and form the fundamental basis for the of the book of key explanations instructions rest include the complete examples these chapters also tutorial instruction sets so serve as on a efficient chapters and demonstrate how code with of 5 6 write example that to scores we have developed while working with arm chapter teaches techniques 5 customers proven xi
xii preface for efficiently and rules writing code that will compile the arm architecture and c it on should optimized details for helps determine which code be chapter best practices writing 6 and code for reducing optimizing arm assembly critical improving performance by and clock speed consumption system power basic used wide of algorithms its worth because primitives operations in are a range while learn how optimized discusses they be chapter z how optimize primitives to to can for specific optimized reference implementations of arm lt presents processors com primitives well of complicated mathematical for those operations who mon as as more included behind wish take quick reference we have also the theory each to approach a for deeper implementation those who wish dig to embedded audio and video applications increasingly demand they systems in are would require digital signal processing dspy capability that until recently have been pro vided architecture offers higher by dsp now however the arm separate processor a bandwidths and faster multiply permitting accumulate operations single arm memory a design these applications chapter s examines how maximize the to support to core per formance of the for digital and arm processing applications how implement dsp to algorithms of embedded efficient the heart lie the handlers handlers at exception an system performance dramatically improve chapter 9 the theory and system can covers prac of of handling and interrupts the arm through detailed tice exceptions processor set on a examples of embedded described firmware important chapter 10 by part system 1s in an any ofa firmware designed called sandstone the simple package chapter also reviews means we popular industry firmware packages that available for the arm are chapter demonstrates the implementation of embedded 11 operating through systems designed called simple little system example operating operating system an we chapters 12 and focus issues chapter 12 the 135 14 examines various memory on surround cache technologies that the arm demonstrating routines for controlling cores cache specific cacheenabled discusses the arm chapter 13 the on processors memory protection unit and chapter discusses the 14 unit memory management consider of architecture highlighting finallys in chapter 15 the future the arm we directions the and in instruction technologies that arm is implementing set in new new the few next years the appendices provide detailed references and the instruction cycle timing sets on specific products arm examples web the on noted earlier have created of tested practical as extensive examples set to we we an reinforce and methods these available the publishers web site concepts at are on comicompaninsssis mkpad wwwa
xii preface acknowledgments of shau chin and yulian and families first wives symes yang who have courser are our and spending of been supportive have with large home proportion very put us our up a this time project on this book has complete and have contributed with taken people to many years many and technical advice we would like thank all the encouragement personally people to involved writing technical book involves lot of painstaking attention detail big to a a so a thank all the who and effort reading and providing feedback reviewers time to spent you sa diffcult activity that requires special skill reviewers who worked with the publisher during a siliconi insiderl codesprite the developmental jim turley peter maloy process were chris harrod ltds wolf larsen peter arm gary thomas mlb associatess wayne princeton universitys scott qualcomm niall panelsoftl and runner ince murphy s calgorithmics ltd dominic sweetman de special thanks dijkstra edward nevilly and david seal for a wilco allowing to to us include selected examples within the book thanks rod crawford andrew also cum to and mins flynn jamie smith william anne for helping throughout dave rees rooney with advice thanks the strategic support howard john archibald arm group ho to miguel echavarria robert allen and field for reading and providing quick local ian feedback would like thank john rayfield for initiating this and contributing we project to chapter would like thank david for and 15 we also brash reviewing the manuscript to include material this book allowing armv6 in to us wish thank kaufmann publisherss and lastlys morgan especially denise penrose to we belinda for their and advice throughout the breyer patience project
this page intentionally left blank
11 the risc design philosophy 12 the arm design philosophy 121 for embedded systems instruction set 13 embedded system hardware 131 arm bus technology amba 132 bus protocol 133 memory 134 peripherals 14 software embedded system 141 initialization code boot 142 operating system 143 applications 15 summary
cnatee l arm embedded systems the arm key of successful 32bit embedded is core component many systems processor a probably yourself and realize widely used you itl arm not in own one may even cores are mobile handheld and multitude ofother portable phones organizerss everyday consumer a devicess designers from arms have long the frst armi in 1985 over come prototype a way billion worldwide end arm had been shipped by the of 2001 the arm one processors bases their simple and powerful original design which continues success company on a today through technical innovation in fact the arm to improve constant is core not family of designs design and single but whole sharing similar principles a cores a a common instruction set successful example of arm the armttdml provides for is it s most to one cores up mips and for high code density and low 120 dhrystone is known its consumption power making ideal for mobile embedded devicess it risc reduced in this frst chapter discuss how the instruction design set computer we philosophy flexible embedded introduce adapted by arm we then to create was a processor embedded device and discuss typical hardware and software example the technologies an surround that arm an processor dhrystone mips small benchmarking l version 25 is l a program 3
chapter arm embedded systems l 11 the risc design philosophy risc architecture risc design philosophy aimed delivering the arm is at core uses a a simple but powerful that within cycle high clock speed instructions execute single at a a reducing the risc philosophy the complexity of performed concentrates instructions on the hardware provide flexibility and intelligence software by because it is easier to greater in rather than hardware risc design demands the as result places compiler greater a on a in the traditional complex cisc relies the instruction contrast set computer more on hardware for instruction functionalitys and cisc consequently the instructions are more complicated figure illustrates these differences 1l major the risc philosophy is implemented with four design rulesi major risc have reduced number of these instructions instruction classes l processors a classes provide simple operations that each in single cycle the compiler execute can a complicated for divide synthesizes operations example operation programmer or a combining each fixed by several simple instructions instruction length allow 1s to a before the pipeline fetch future instructions decoding the instruction in to current the often of variable and in cisc instructions size take contrast processors are many cycles to execute pipelines of broken 2 the processing instructions is down into smaller units that be can executed pipelines ideally advances in parallel by the pipeline by each cycle step one on for throughput decoded there instructions be in pipeline maximum stages 1s can one called need for instruction be executed by miniprogram microcode to an no a as on cisc processors risc machines have large 3 registers general register any register purpose set a can contain either data address the fast local for all data registers act memory store or an as cisc risc greater compiler compiler complexity code code generation generation greater processor processor complexity figure 11 cisc risc cisc emphasizes hardware complexity risc emphasizes compiler vs complexity
philosophy 5 12 the arm design dedicated in cisc have for specific processing operations registers contrast processors purposes loadstore architecture data held load the in registerss separate 4 operates processor on and instructions transfer data between the bank and register external store memory memory costly separating from data processing accesses are memory accesses so pro vides advantage because held bank data items in the register multiple an you can use without needing multiple with cisc design times in the contrast memory accessess a data directly processing operations act can on memory these design rules allow risc be simpler and thus the to operate a processor core can higher clock frequenciess in traditional cisc contrast complex at processors are more and of decades lower clock frequencies over the however the operate two at course distinction between risc and cisc has blurred cisc have implemented as processors risc more concepts 12 the arm design philosophy there number of physical features that have driven the arm design first are a processor portable embedded form battery require of the arm has systems some processor power specifically designed reduce and extend been be small consumption battery to to power mobile operation essential for applications such phones and digital assistants personal as pdas code density another embedded lim high is major requirement since have systems ited due andlor physical restrictions high code density useful for size to cost 1s memory applications that have limited board such mobile phones and on memory storage as mass devices embedded in addition sensitive and and lowcost price slow systems use memory are highvolume devices for applications like digital has be accounted cameras every cent to for design the devices produces the ability lowcost substantial in to savingss use memory another reduce the oft the die taken the embedded important requirement is byt to area up embedded for singlechip solution the smaller the used by the processor area processor a available for specialized peripherals this reduces of the in the the turn cost more space design and manufacturing fewer discrete chips required for end product since the are arm has incorporated hardware debug technology within the that software processor so what while code engineers view is happening the is executing with can greater processor visibilitys software resolve faster which has direct effect engineers issues the time can a on and reduces overall development to market costs architecture of of the arm risc because the constraints primary 1s not its core pure a application embedded of arm the in the strength the that system is some sense core risc it does take the fars in todays the key not too systems is not concept processor raw effective performance and speed but total consumption system power
6 chapter arm embedded systems l 121 instruction set embedded systems for the differs from the risc definition arm instruction in several that make set pure ways embedded the arm suitable for applications instruction set variable cycle execution for certain instructions not arm instruction every executes loadstore in single cycle for example multiple instructions in the number a vary of cycles depending the number of being transferred the execution registers upon addresses performance transfer sequential which increases since can occur on memory faster random code density sequential often than is also memory accesses are accesses improved multiple transfers the and end since register operations at start are common of functions inline barrel shifter leading complex instructions the inline shifter barrel is to more hardware that of the before used input registers it is component preprocesses a one capability of by instruction this expands the instructions to improve an many core and density this feature detail performance code we explain in in chapters 2 35 more and 4 enhanced the adding second thumb 16bit instruction arm by set processor core a 16bit called thumb that the either instruction permits arm set to execute core 32bit the l6bit code density 16 instructions instructions improve by about or 3000 32bit fxedlength instructions over conditional instruction executed when specific condition has executionan is only a been satisfied this feature performance and code density by reducing branch improves instructions enhanced the enhanced digital instructions signal dspi instructions processor were added the standard arm fast 16xl6bit multiplier instruction to set to support oper and performing ations saturation these instructions allow fastere arm in processor a the traditional combinations ofa replace plus dsp to some cases processor a these additional features have made the arm of the commonly processor most one embedded used 32bit many of the semiconductor around companies processor cores top based around the world produce products the arm processor 13 embedded system hardware embedded different control devices from small found systems can many sensors on production line the realtime control used nasa probe all to systems space a on a devices combination of software and hardware these each components component use a efficiency if applicable designed for future is chosen for and is extension and expansion
embedded hardware 13 system rom sram arm flashrom processor memory controller dram interrupt controller ahbexternal bridge external bus ahb arbiter ahbapb bridge ethernet ethernet real time clock physical driver counterltimers serial console uarts arm controllers peripherals bus figure 12 of embedded example armbased device microcontroller an an a embedded figure shows device based arm each box 12 typical represents a on an core feature function the lines the boxes the buses data we connecting carrying are a or can device four hardware the into separate main components the controls the embedded device different of the arm versions arm processor pro desired available suit the operating characteristics an arm cessor are to processor the and comprises execution engine that instructions manipulates core processes a data the surrounding that interface with these plus it bus components components a include and caches management can memory controllers coordinate functional blocks of two important the commonly system found controllers interrupt and controllers are memory peripherals provide capability and the all the inputoutput external the chip to are responsible for of embedded devicer the uniqueness the different of device bus is used communicate between the to parts
8 chapter arm embedded systems l 131 technology arm bus embedded different bus technologies than designed for pcs those x86 the systems most use pc bus technology the peripheral component pci bus interconnect common connects devices video cards and hard disk the this such controllers x86 bus to as processor type of technology offchip ies the bus designed mechanically and is external is to connect or electrically devices external the chipl and built the motherboard ofa pc is into to to embedded in devices onchip bus that is internal the chip and that contrast use an to allows different peripheral devices be interconnected with arm to an core different of devices attached there classes the bus the arm to is are two processor core bus device capable of transfer device logical initiating data with another master a across a a the peripherals tend bus slaves devices of responding bus be logical capable only same to transfer from bus device to request master a a bus has architecture levels the frst is physical level that the electrical a two covers a characteristics and bus width 116 bitss the second level deals with 32 64 protocol the or logical rules that the communication between the and peripheral govern processor a seldom arm is primarily design it implements the electrical characteristics a company of specifes the bus but it routinely the bus protocol 132 amba bus protocol advanced microcontroller architecture introduced and the bus amba in 1996 has was architecture been widely adopted the onchip bus used for arm the frst as processors introduced and amba buses the arm system bus asbj the arm peripheral bus were introduced another design called performance apbl later arm bus the arm high bus peripheral designers design multiple cahby using amba the projects can reuse same on there large number of peripherals developed with amba interface hard because are a an designers have wide choice of tested and peripherals for device in ware proven use a a peripheral be bolted the onchip bus without having redesign a simply inter can onto to an different face for each architectures this plugand interface for hardware play processor developers availability and market improves time to provides higher data throughput based centralized ahb than asb because it is on a this multiplexed bus scheme rather than the asb bidirectional bus design change allows higher clock speeds and first widths the ahb bus be the arm bus to at to to support run of and bits introduced 6a 128 arm has variations the ahb bust multilayer ahb two on and ahblite in the original ahb which allows single bus be contrast to master to a active the bus the allows multiple time multilayer ahb bus active bus at masterss on any ahblite subset of the bus and is limited single bus this bus is ahb it to master a a was developed for designs that do the full features of the standard ahb bus require not and for and ahb multilayer ahb the protocol slave but have support master same different the multilayer good for interconnects interconnects in ahb systems new are with multiple they permit operations parallel and allow for higher to in processors occur throughput rates
9 embedded system hardware 13 the example device shown figure 12 has three busest ahb bus for the high in an performance peripherals apb bus for the slower peripherals and third bus for external an a peripherals this devices this specialized proprietary external bus requires bridge to to a with the ahb bus connect 133 memory embedded form of and code an has have you system to to execute some memory store performance and deciding specific have price consumption when to compare power upon characteristics such hierarchy width and if has twice as type memory to memory run as desired fast maintain bandwidth then the be higher to requirement a memory power may 1331 hierarchy all arranged form of hierarchy shows have in figure 12 computer systems memory some device that offchip the there external internal is option supports memory to a processor an ofa cache not shown figure 12 performance in improve to memory tradeoffs located figure 13 shows the the fastest cache physically 1s memory memory the arm and the slowest secondary further is processor core set nearer memory away generally the closer the the it and the smaller 1s to its memory processor more costs core capacity the cache placed between and the used speed data is main it is to memory cores up transfer between and cache provides overall the main a processor memory increase in an performance but with of predictable although loss execution the cache the time increases a cache e main memory secondary storage mb 1 gb 1 memory size figure offs 13 storage trade
10 embedded chapter systems l arm general performance of the does help realtime note that it system not system response embedded small do require the performance benefits ofa cache systems not many around depending the main is large 256 kb 256 mb or to greaters memory even on the application and is generally stored in chips load and instructions separate store access stored for the main unless the values have been the cache fast secondary in memory access and form of hard disk drives and drives is the largest slowest cdrom storage memory of secondary these days secondary from examples 600 mb storage storage are may vary 60 gb to width 1332 width the number of bits the is the each typically returns memory memory on access bits the width has direct effect performance and 8 16 32 64 the overall or memory a on ratio cost uncached 32bit igbitwide ifyou have using arm instructions and system an memory chipss will fetches fetch then the have make instruction each to two processor memory per 16bit loads effect of reducing this obviously has the performance requires system two beneft 16bit less but the is that is expensives memory if l6bit thumb will achieve better in the instructions it contrast executes core performance with l6bit the higher performance result of the making is memory a a core fetch load thumb only single instruction hence using instructions to to a memory an with 16bite wide devices provides both improved performance and reduced memory cost different table theoretical cycle arm 11 summarizes times using on an processor width devices memory 1333 types different of this describe of there in section the are many types memory we some more embedded popular devices found in armbased memory systems readonly ofall rom is the least flexible because it contains memory memory types an that production and reprogrammed image is permanently time be roms set cannot at are used in highvolume devices that updates devices require corrections many also no or use hold rom boot code to a table 11 fetching instructions from memory instruction sbit l6bit 32bit size memory memory memory arm 32bit cycles cycles cycle f 2 l thumb l6bit 2 cycles cycle cycle l l
embedded system hardware ll 13 flash rom be written well read but is slow shouldn it write t can to to as as so you use for holding holding dynamic data its main is for the device frmware storing long it use or needs preserved after off and offlash data that be is the erasing writing rom term to power controlled additional completely software with hardware circuity required which no are readonly reduces the manufacturing flash rom has become the popular oft the costs most and being used for secondary is currently alternative types memory as an mass storage or random dram used for devices dynamic 1s the commonly ram most access memory it has the lowest megabyte compared with other ofram dram dynamic is cost types per needs have cells refreshed and few it its given electronic charge to storage new every a milliseconds need dram controller before the using to set so you up a memory static random sram faster than the traditional dram but is access memory more requires silicon sram is static sthe ram does require refreshing the not more area for considerably equivalent time sram is shorter than the dram because sram access of does require between data higher used mostly because its it 1s not pause accesses cost a for smaller highspeed such and caches tasks fast as memory dynamic random sdram of subcategories synchronous is many access memory one of dram much higher clock speeds than sdram it conventional at memory can run synchronizes itself with the bus clocked data fetched because it is internally the processor is from cells pipelined and finally brought the bus the oldstyle in burst out memory on a dram asynchronous does burst efficiently sdram is not so as as 134 peripherals embedded with outside world need form of that interact the peripheral systems some device peripheral device performs and functions for chip the by connecting a input output other devices off peripheral device performs that chip each usually single to or sensors are a function and reside onchip peripherals from simple serial communication may range a device complex device 8025 11 wireless to more a all peripherals mappedthe interface of arm programming is set are memory a offset memoryaddressed the address of these from specific registers registers is an a address peripheral base controllers specialized peripherals that implement higher levels of functionality are within embedded two of controllers controllers system important types are memory an and controllers interrupt memory controllers 1341 different of memory controllers the bus connect to on types memory processor power up configured devices controller is in hardware allow certain be active to memory memory to a these devices allow initialization code executed the be some devices to memory memory be softwares for when dram first have by example using the must set to set up you up and refresh before accesseds timings it be memory rate can
12 embedded chapter systems l arm controllers 1342 interrupt peripheral device when requires attention it raises interrupt the to or an processor a an interrupt controller provides programmable governing policy that allows software to a determine device specific which peripheral the interrupt time by or can processor at any bits setting the appropriate in the interrupt controller registers there of available for standard interrupt controller the arm the two types are processor interrupt controller and the controller vicy interrupt vector the standard interrupt sends controller interrupt signal the when to an processor core external device servicing it be programmed individual ignore mask requests can to an an or device of devices the interrupt handler determines which device requires servicing set or reading by device bitmap register the interrupt controllers in a the powerful the standard controller because vic is than interrupt prioritizes it more and simplifies of interrupts the determination which device caused the after interrupt and handler address each vic associating priority with interrupt the only asserts a a an if the of higher interrupt signal the priority interrupt is than the currently to core a new handler depending its the vic will either call the standard executing interrupt type on handler which load address of handler for device from interrupt exception the the the can the vics the the handler for the device directly jump to to or cause core 14 embedded system software embedded needs drive figure four software an software it 14 shows typical system to embedded device required control each software the components to in component an higher of code from hardware devices stack level abstraction the the to separate uses a the initialization code the first code executed the board and specific is is particular on to a of the minimum of the board before handing it control target targets sets parts or group up the operating to system over application operating system initialization device drivers hardware device figure 14 software layers hardware abstraction executing on
embedded 13 system software 14 the provides infrastructure control applications and operating system to manage an embedded hardware many do full operating system systems require resources not system a scheduler driven but merely simple task that is either poll event a or third the device drivers the shown figure they provide in 14 component are software hardware consistent interface the peripherals the device to on a forms of required for device finallys application the tasks for example an peri one a mobile phone might have diaryt application there multiple be applications running a may a the device controlled by the operating same system on the software from ram code that fixed rom rom is the components can run or on device for the initialization code called frmware example is 141 code initialization boot initialization code or boot code takes the from the where the processor reset state to state a configures operating lt usually the controller and caches system can runs memory processor and initializes devices might replaced in simple the operating be by system system some a simple scheduler debug monitor or a the code handles number ofadministrative handing initialization tasks prior control to a different operating image we these tasks three phasest to system into over an can group initial hardware configuration diagnostics and booting hardware configuration platform initial involves setting the it boot target so can up although the platform itself standard configuration this image in target comes an up a configuration normally modification satisfy the of booted requires requirements the to of for example the normally requires reorganization the imager system memory memory shown in example 11 maps as embedded diagnostics often the initialization code diagnostic code the in tests are if by exercising the hardware check the is working orders also system to in it target target down standard systemrelated this of for tracks issues testing is important type manu facturing it software product of since after the is completer the primary occurs purpose diagnostic code is fault identification and isolation loading and handing that the boot booting involves image control to image an over itself be complicated if the different boot operating process can system must systems or different of versions the operating same system final first load loading booting image is the phase but the must image image an an you anything including code and data involves from copying entire ram into an program to data containing volatile variables ram once booted the just copying into area system a hands modifying of control by the point the the counter into start image over program to reduce compressed the sometimes the size image is then to image image is an decompressed either when loaded when control handed it is is it to or over initializing of because organizing the initialization code example is important part or memory an 11 before operating known layout they systems expect start many a memory can
14 embedded chapter systems l arm before after oxfffffff ijo regs ijo regs fast sram boot rom dram dram large large contiguous contiguous block block boot rom fast sram ox00000000 figure 15 memory remapping figure 15 shows before and after reorganization is for armbased it common memory embedded provide for because allows the remapping it systems to system to start memory redefines the initialization code from rom the initialization code then at power ups or address the place ram oxo0000000 because at important step remaps memory map to an then the table and thus exception be in ram be reprogrammed we will vector can can discuss table detail the in in section 24 vector more 142 operating system the initialization the hardware for operating take prepares system to process an control an operating organizes the the peripherals system system resourcest memorys and with these processing time operating controlling they be system an resources can efficiently by different applications within used running the operating environment system divide arm 50 operating we operating systems processors support over can systems and into main categories realtime operating rtoss platform operating two systems systems different rtoss provide guaranteed have times operating response to events systems different of hard application control the time a real time amounts system over response guaranteed all soft realtime requires work in application to at contrast a response a gracefullyifthe good but the performance degrades requires time response more response a rtos time systems running generally do have secondary not overruns storage an platform operating require unit large systems management to a memory manage non and tend realtime applications have secondary the linux to operating 1s storage system ofa platform typical example operating system a
15 summary 15 these of exclusiver there categories operating mutually two system are not operat are that arm with unit and have realt ing systems time core memory management use an a developed of specifically characteristics arm has that each set a processor cores target category 143 applications the schedules code dedicated handling operating applications particular task system to a application implements processing the operating controls the an task environ system a embedded have active application several applications running ment an system can one or simultaneously found in market including networking arm are numerous segmentss auto processors mobile and devices and within motive each storage imaging segment consumer mass be found multiple applications arm in processors can example the found networking applications like home for arm in is processor dsl modems for highspeed internet communication and 8025 wireless 11 gateways device for communication the mobile is the largest application arm segment area pro because of mobile phones arm also found devices in cessors processors storage are mass drives such hard and imaging products such inkjet printers applications that as as are cost high sensitive and volume found applications that leadingedge in arm in require contrast not processors are high performance these applications tend be low volume and high arm because to cost decided focus designs applications has these of not to on types 15 summary aimed high performance modifed design pure risc is but arm risc philosophy at uses a that good code density and embedded also low consumption an targets system power surrounded consists of by caches and peripherals the system is processor core memory a controlled software that by operating application tasks system manages the risc design performance reducing key points in philosophy by to improve a are the complexity of speed pipeline instructions instruction processing by using to to up a provide large data the and loadstore architecture register to set store to use a near cores a the design philosophy nonrisc ideast arm also incorporates some it allows variable cycle execution instructions and certain to area on save power code sizer adds barrel shifter expand the capability of it certain instructions to a 16bit code density it the thumb instruction improve set to uses
16 embedded chapter systems l arm performance conditionally it code density and by improves executing instructions includes enhanced lt instructions perform digital signal processing functions to type embedded includes following the hardware arm an system components processors found embedded in chips programmers peripherals through memorymapped are access there of peripheral called controller which embedded registers is special systems a type a configure higherlevel functions such and amba onchip interrupts the to use as memory used and peripherals bus is the together to connect processor embedded includes the following software initialization an also system componentst code configures the hardware known configured operating once be to state systems a can loaded and executed operating provide programming for systems environment common a of hardware and infrastructure drivers standard the device provide interface use resources a taskspecific peripherals application performs the duties of embedded an to an system
this page intentionally left blank
21 registers 22 current program status register 221 modes processor 222 banked registers 223 state and instruction sets 224 interrupt masks condition 225 flags conditional 226 execution 23 pipeline 23 pipeline executing characteristics 1 24 exceptionss vector table interruetss and the 21 5 core extensions cache and tightly coupled memory 251 25 52 memory management 2453 coprocessors 26 architecture revisions 25 6 nomenclature l architecture 2 62 evolution 27 arm processor families arm7 family 271 272 arm9 family armio family 273 274 armi1 family specialized 275 processors 28 summary
cnatee 2 arm processor fundamentals chapter covered embedded with this chapter will focus l arm in systems an processor we itself the first will provide of the and actual overview processor on we an processor core describe different how data between its we will describe the programmers moves parts s model from developer of software view the arm which will show the s processor you a functions of and how different look the interact we will also take parts at processor core a form speed and the extensions that arm core extensions organize core an processor up extend then main well the instruction we will the revisions the set to memory as as cover architecture by describing arm used identify arm the naming conventions to core core architecture them and the chronological changes the arm instruction the inal to set introduces architecture subdividing section the implementations by them specific into arm families core processor of functional connected think arm units by data buses a programmer can an core as where of data lines shown in figure 21 the the flow the the represent as arrows represent buses and the either the fgure boxes operation unit shows represent storage an or a area the flow of data but also the abstract that only make arm not components up an cores the bus the data data through the data be instruction enters to processor core may an data shows von neumann of arm item figure 21 nentation the execute or a a data items and instructions share the bus harvard implementations of in same contrast different the arm buses use two the instruction decoder translates instructions before they executed each are instruction executed belongs particular instruction to set a risc loadstore architecture this the arm like all processor processorss uses a has for transferring data and of load it instruction in the two types out means processor instructions data from the and registers in conversely the to store copy memory core 19
20 chapter fundamentals 2 arm processor data instruction decoder sign extend write read rl5 rd register file rorls result pc a b rn rm b acc barrel shifter mac n alu address register incrementer address figure 21 dataflow model arm core instructions data from there data processing registers to instructions copy memory are no carried that directly manipulate data thus data processing solely in is in memory out registers placed the file made of 32bit data items in register bank registers storage are a up since the arm 32bit instructions the registers holding 1s most treat core a processor as signed unsigned 32bit the extend hardware signed 8bit and l6bit values sign converts or numbers 32bit values read from and placed they in register to as are memory a arm instructions typically have and rm and single result registers rn two source a or destination file rds source operands read from the register the internal register using are buses and respectively a b the alu arithmetic logic unitl mac umultiplyaccumulate unit takes the regis or and and and values rn rm from the a b buses result data ter computes processing a rd directly the fles load and instructions write the result in register instructions to store address address broadcast the alu be held in the and the to generate to register use an on address bus
21 2a registers l important feature of the arm that rm alternatively be preprocessed one is register can shifter before shifter the barrel it the alu together the barrel and alu in enters can of and addresses calculate wide expressions range a functional rdis after through the units the result written back the passing in to register fle load using the result bus for and instructions the incrementer updates the address store before reads register the writes the register value from the sequential next to next core or or location the continues executing instructions until exception memory processor an or changes the normal flow interrupt execution of we ll detailed look now that have overview the take you an processor core a more of the of the key the registers the at components processor current status some program and the pipeline register cpsrs 2 81 registers hold either address identifed general registers data they with the purpose or are an letter prefixed number label the register for example register the to 4 1s given 54 t shows the available mode protected mode figure 2 2 active registers in normally user a ro rl 2 r3 s r6 r7 re r9 rlo rll rl2 rl3 sp rl4 lr rl5 pc cpsr figure 22 registers available in mode user
22 chapter fundamentals 2 arm processor different used when applications the modes executing in operate processor can seven bits which will introduce shortly all the shown 32 registers in sizer are we there data 18 active registers 16 registers and the to 2 status registers are processor up data visible the r15 registers to ro programmer to are as function the arm has three registers assigned particular task special to processor or a and frequently different labels differentiate rl3 rl4 r15 they given them from the to are other registers figure 22 the shaded identify the assigned speciall in registers registers purpose register r13 is traditionally used the and the head of the stack pointer stores stack as spi the mode in current processor called the link lr and where the the address register rl4 is register is puts return core whenever calls subroutine it a register r151s the pc and contains the address of the instruction counter program next be fetched by the to processor depending and the registers r13 also be used general context rl4 upon can as purpose useful banked during registers which be particularly since these registers can are processor a dangerous mode change however it is r13 general register when the to use as processor a of is running form operating because operating often that rl3 system systems assume any valid frame always points stack to a r13 that in arm the registers ro orthogonal instruction state to apply are any you can equally well of the other there ro apply registers however instructions to to are you can any and that r15 in special treat rl4 a way addition the data there and in 16 registers registers to two status are program cpsr spsr the and saved respectively current status registers program file available which the register contains all the registers registers to programmer are a visible depend mode of the the the to current programmer upon processor 22 current status program register the the and control arm monitor internal operations the is to core uses cpsr cpsr a dedicated 32bit and resides fle shows the register in the register figure 2 3 basic layout of note that the shaded reserved for future generic register status parts a program are expansion four the is divided into felds each bits wider flagss and 8 extension control status cpsr designs the and felds reserved for future the control in current extension status are user feld bits feld contains the mode and interrupt mask the flags contains state processor condition flags the bits allocated some arm have for example the jbit which extra processor cores can found feld available jazelleenabled be in the flags only which 1s execute on processorss
23 current status 22 program register flags status extension control fields bit 31 30 29 28 7654 n z mode function condition interrupt processor flags masks mode thumb state figure 23 a generic register psr status program sbit instructions discuss jazelle in section highly probable that we will 223 it is more future designs will bits for monitoring and control oft features assign the extra new of appendix for full description the refer to b a cpsr 221 modes processor determines the mode which and the rights the registers active access to processor are cpsr itself mode either privileged nonprivilegeds privileged mode register each is a processor or allows full read nonprivileged mode read write the conversely only allows to access cpsr a the control feld in the but still allows read the condition flags to write access access to cpsr modes modes there in total privileged abort fast six interrupt are seven processor and undefned and nonprivileged interrupt supervisor mode system request request one user the mode when there failed abort is fast enters attempt to processor a access memory interrupt and modes correspond available interrupt the interrupt levels request request to two the arm supervisor mode the mode that the after and is is processor processor in reset on generally the mode that operating kernel system mode special is system operates in is an a of mode that allows full readwrite undefined mode used version the is to user access cpsr when the instruction that undefined supported by the is processor encounters not an or mode for and implementation user is used applications programs 222 banked registers figure shows file of hidden from 24 all 37 registers in the register those 20 registers are different called banked identifed these and times registers registers program at are are a shading diagram available by the in the they only when the is particular in are processor a
24 chapter fundamentals 2 arm processor user and system ro rl r2 s fast interrupt ro request r7 r8 rs fiq r9 fiq r9 rlo rlo fiq interrupt rll rliljiq supervisor undefined abort request rl2 rl2 fiq rl3 rl3 rl3 rl3 rl3 rl3 fiq irq undef abt sp svc lr fiq undef rl4 rl4 rl4 irq rl4 rl4 rl4 abt svc rl5 pc cpsr fiq undef abt irq spsr spsr spsr svc spsr spsr figure 24 complete arm register set mode for example abort mode has banked r13 abt abt and abt banked registers rl4 spsr ofa underline registers particular mode denoted by character fixed the mode are an post to mnemonic mode or mode mode change mode by writing directly every the except to processor user can of of mode bits the all modes mode have associated system processor except set cpsr a banked subset of banked registers that the main 16 registers a register are a maps one to mode if mode banked from register change register the onto one user you processor a a mode will replace existing register new an mode for example when the is in the interrupt the instructions processor request you still named and these the banked registers r13 r14 however registers execute access are r13 and the mode and affected registers rl4 irq registers r13 rl4 irq user are not usr usr the referencing by instruction these registers still has normal the other a to program access registers ro rl2 to mode directly the be changed by that writes the the to processor can program cpsr a privileged model hardware responds has be in by when the to to processor core or core
25 current status 22 program register user mode ro rl 2 r3 rs ro r7 r8 r9 interrupt rlo request rli mode rl2 rl3 rl3 irq sp rl4 rl4 lr irq rl5 pc cpsr irq spsr figure 25 changing mode exception on an the following and mode changer exception interrupt exceptions interrupts an or cause a fast software data abort prefetch abort interrupt interrupt interrupt reset request request undefined and instructions exceptions and suspend the execution of interrupts normal and specific sequential instructions jump location to a illustrates what forces mode changes figure figure 25 happens when interrupt the an a from mode shows the changing mode which happens when to interrupt core user request an due device interrupt external raising interrupt the request to to occurs an an processor core this and banked the replaced change registers rl3 rl4 be to registers causes user user are with and respectively note the address registers rl3 irq rl4 irg rl4 irq contains return and for mode r13 contains the stack pointer interrupt irq request also shows interrupt moder saved figure 2 5 register appearing in the request a new which modes you status register the previous the program spsrs stores see in cpsr can copied diagram the being into to back mode special to return cpsr spsr irq return user a used and instruction is that instructs the the original from the to restore irq core cpsr spsre and modifed read bank in the registers r13 note that the be and rl4 only in user spsr can a privileged mode available mode there is in no spsr user
26 chapter fundamentals 2 arm processor table 25 l processor mode mode abbreviation privileged modelasol abort abt 10111 yes fq 10001 fast interrupt request yes interrupt irq 10010 request yes supervisor 10011 svc yes system 11111 sys yes undefned und 11011 yes user io000 usr no another feature that copied important is the is into the when to note cpsr not spsr a mode forced due directly of change is writing the the saving the to to a program cpsr cpsr when raised only exception interrupt is occurs an or signifcant figure shows that the active mode the five least 23 occupies current processor bits of the when applied mode which is the it in supervisor is to starts cpsr power core privileged starting privileged mode useful initialization code full in is since use access a can for of the the stacks each the other modes to to cpsr set up lists modes and binary of table 21 the various the associated the last column patterns the table the bit that of modes gives each the the patterns represent in processor cpsr 223 state sets instruction and the of the determines which instruction is being executed there three state core set are thumb and jazelle the arm instruction arm instruction is only active when setsi set the similarly the thumb is in arm instruction is only active when processor states set the is in thumb thumb the once in state is executing purely processor stater processor l6bit and thumb instructions you intermingle sequential arm thumb jazelle cannot instructions and tbits of the jazelle t thumb in the reflect the the when both state cpsr processor jand tbits and this o the is in arm arm instructions the state executes is are processor applied when the t bit when is the is l then the is in to case power processor processor thumb to change the specialized branch table states executes instruction 2 2 stater core a features the arm and thumb instruction set compares the designers introduced third instruction called jazelle jazelle arm set executes a hybrid designed sbit instructions and is mix of software and hardware speed the to a up execution of java bytecodes bytecodes the jazelle technology modifed to java require plus specially execute you a of machine version the java virtual it is important that the hardware portion of to note of bytecodess emulated jazelle only subset the java the softwares supports in rest are a
27 current status 22 program register table 22 and thumb features arm instruction set thumb arm te oj te cpsr ld cpsr instruction size 32bit bit 16 core instructions 58 30 executiona conditional only branch instructions most shifter shifter and data processing barrel and barrel to separate access instructions alu alu instructions read privileged mode direct program register write in status no access register 15 generalpurpose 8 generalpurpose registers registers usage high registers tpc l7 fi pc a see section 22 6 table 23 jazelle features instruction set jazelle cpsr te o jal 8bit instruction size of core over 6000 the java bytecodes implemented hardwares instructions in are of the the codes implemented software rest in are the jazelle closed and available table instruction is instruction is openly 23 set set not a the jazelle instruction features gives set 224 interrupt masks specific used interrupt from the interrupt masks interrupting to stop requests are processor there levels available the arm interrupt interrupt two request are on processor core and fiq irqy fast interrupt request request the has bits and 6 or and fs which control the masking interrupt mask z l two cpsr of and irq and fiqq respectively the bit masks irq when binary similarly l l the set to bit binary f masks fiq when to l set 225 condition flags condition updated by and of flags comparisons the result alu operations that specify are the s suffx ifa subs subtract instruction for example instruction results in aregister value this specifically of then the z flag the is particular subtract instruction in zeros set cpsr updates the cpsr
28 chapter fundamentals 2 arm processor table 24 condition flags flag set when flag name andlor e saturation the result overflow saturation causes an signed overflow the result overflow causes a the result unsigned carry causes an carry frequently used indicate zero the result is equality to zeros bit of result binary negative 31 the is l a with that include the dsp bit indicates ifan overflow extensions the qi processor cores occurred enhanced c saturation has in dsp instruction the flag sticky the is in or an hardware this need that the only flag to clear the flag write the sets sense to to cpsr you directly jazelle enabled the jbit reflects the of the ifit in is the is state set processors cores core in jazelle the jbit generally usable and is only available state is not on some processor cores advantage of jazelle software be licensed both limited and to take has from arm extra to sun microsystems executed conditionally of condition most arm instructions be the value the can on flagss lists condition and description table 2 4 the flags short what them be to a causes on these located the significant bits these bits used for flags in in the set most are cpsr are conditional execution typical for with dsp and figure 2 6 shows value the both extensions jazelle in cpsr a this that data human readable form book notation the in presents we use a cpsr a more when bit binary capital letters when bit binary lowercase is l is o a a a we use a a we use a letter condition capital letter the flag for the flags shows that has been for interrupts set a capital letter shows that interrupt disabled is an a condition the example shown figure 26 the cflag the only flag the in in is set rest cpsr neither flags all clear the is in arm because the jazelle jor thumb state nzvq are processor t bits the enabled and disabled irq interrupts fiq interrupts finally set are are are you 29 54 81 30 28 27 24 7 6 10011 svc nzcvq if figure 26 example nzcvvift svc cpsr s
29 pipeline 23 table 25 condition mnemonics mnemonic condition flags name eq equal z ne equal not z c higher cs hs setlunsigned same carry or cc lo clearlunsigned lower carry  mi minusl negative positive pl plusl or zero vs overflow vc overflow no v hi unsigned higher zc ls unsigned lower zor same or c  signed than equal nvor greater or nv signed less than nvor nv signed than nzvor greater nzv signed less than equal zor nve nv or or unconditionall ignored always from figure svc modefaol the the is in supervisor mode since the 1s can see processor binary equal 10011 to 22 6 conditional execution conditional whether execution controls the will instruction not execute core an or condition determines if most instructions have attribute that the will execute it a core based of the condition flagss the setting prior execution the the to on processor compares condition attribute with the condition flags the if they match then the in instruction cpsr executed otherwise the ignored is instruction is the condition attribute postfixed the which encoded is instruction mnemonic is to conditional into the table 25 lists the execution code when instruction mnemonics a condition mnemonic is the default behavior al is to set it to always execute not present 23 pipeline mechanism risc a pipeline is the instructions using pipeline to execute processor uses a a speeds fetching while other execution by the instruction instructions being next are up decoded and of automobile executed one view the pipeline think it to is to as way an assembly line manufacture vehicle with each carrying particular task the stage out to a
30 chapter fundamentals 2 arm processor fetch decode execute figure 27 threestage pipeline armz three pipelines figure 27 shows stage a fetch loads from instruction an memory identifes decode the instruction be executed to the and back execute instruction writes the result register to processes a illustrates the pipeline shows of three figure 28 using simple example it a sequence a being fetched decoded and executed by the instructions each instruction takes processor filled single cycle complete after the pipeline is to a first the three instructions placed into the pipeline sequentially in the cycle the are fetches the add from the second the fetches instruction in cycle the core memory core sub instruction and decodes the add the third cycle both the sub and instruction in add instructions moved along the pipeline the add instruction executed the sub 1s are decoded and cmp fetched this procedure called filling instruction is the instruction is 1s pipeline the the pipeline allows the instruction cycle to execute core every an pipeline of done reduced as the length increases the work each amount is at stage which higher this allows the attain operating frequency in to turn increases processor a the nance the latency also because fll increases it takes cycles the system to more pipeline before the instruction the increased pipeline lengthalso core execute an can means there data dependency between code reduce this be certain you write stages to can can dependency by instruction scheduling for information instruction scheduling using more on take look chapter at 64 a fetch execute decode time cycle add cycle 2 sub add sub cycle 3 cmp add figure 28 pipelined instruction sequence
31 pipeline 23 fetch decode execute memory write figure 2 9 pipeline armi fivestage fetch issue decode execute memory write figure 210 arm1o pipeline sixstage the pipeline design for each family differs the arm for example arm9 increases core the pipeline length five shown adds and in figure 2 9 the arm9 to stages as a memory which writeback allows the armi dhrystone mips stage to 11 process on average per instruction throughput around compared mhz increase in by 1300 with arm7 an an the frequency attainable arm9 is also higher maximum using core an adding the armio increases the pipeline length still further by sixth shown stage a as figure 210 the armio dhrystone mips about in 15 mhz can process on average per 3400 throughput than arm7 but higher latency again at more processor cores a cost an though and different even the arm9 armio pipelines they still the are use same pipeline code for executing characteristics armtz written the armz will execute as an on armo armio an or 231 pipeline executing characteristics the pipeline has processed until arm instruction it completely through not an passes the for example armz pipeline with three has executed execute stager an stages an fourth fetched instruction only when the instruction is shows pipeline the msr figure 25 11 instruction arm7 instruction an sequence on an used enable irq which msr completes is interrupts only the instruction to once occurs bit the of the pipeline it clears the i the enable the irq execute in inter stage to cpsr add instruction the of the pipeline irq once the interrupts rupts enters execute stage are enabled of and figure 25 12 illustrates the the pipeline the in the counter execute use program pc address of the always points the the instruction plus 8 bytes in other words to stage pc the address of the being executed always points the instruction plus instructions to two pc this used for offset and ahead is important when the is calculating relative is pc an a
32 chapter fundamentals 2 arm processor fetch decode execute cpsr time cycle msr i iftar svc cpsr cycle 2 add msr iftl svc cpsr msr add cycle 3 and ift svc cycle 4 sub and add figure 211 arm instruction sequence lpcs time ox8000 ldr foj pcs 0x8004 nop 0x8008 dcd jumpaddress fetch decode execute dcd nop ldr 8 pc t ox8000 83 f figure 212 example address 8 t pc  architectural the characteristic all pipeliness note when the thumb is in across processor the address the is instruction plus state 4 pc there other characteristics of the pipeline worth first the three mentioning are exe direct modification cution of branch branching by the of the instruction the a or pc causes flush pipeline arm its to core effect second armio branch prediction which reduces the ofa pipeline flush by uses loading address predicting possible branches and the branch of prior the execution new to the instruction third instruction the will though has in complete interrupt execute stage an even an raised been other instructions in the pipeline will be abandoned and the will processor flling pipeline from table the the appropriate in the start entry vector
and 33 the table 24 exceptions interrupts vector 24 exceptionss interruptss vector and the table specific when interrupt the the exception sets to an or occurs processor pc memory a address address within address called table the is special the the entries vector a range the table branch specific designed handle in instructions that routines vector are to to a particular interrupt exception or the address oxoo000000 reserved for table of 32bit is the vector set memory map a words on the table be optionally located higher address vector at some processors can a offset oxf fffooool starting the operating such linux and in at memory systems as microsoft embedded products of this feature take advantage s can when suspends and exception interrupt the normal execution an or occurs processor loading instructions from the exception table see table 264 each table starts vector vector form of ofa specific contains branch instruction pointing the routiner entry to start a first the location of the instruction executed by the reset is when vector processor power applied this branches the initialization code is instruction to undefined used decode instruction is when the instruction vector cannot an processor software called when swi the swi interrupt is instruction vector execute you a instruction is frequently used the mechanism invoke routine to operating as an system prefetch abort when fetch from the instruction vector attempts to an occurs processor an address without the permissions the actual abort the decode correct in access occurs stage abort similar prefetch abort but raised when data is is instruction vector to an attempts a data without the permissions to access memory correct access used hardware the interrupt is by external interrupt normal execution request vector to if flow of the be raised irqs masked it only in the processor not can are cpsr table 26 the tabler vector address shorthand high address exceptionl interrupt oxffffoooo reset oxoo000000 reset undefined fffo004 instruction undef oxo0000004 oxf software oxoo000008 oxffffooo8 interrupt swi prefetch oxoo0000oc oxffffoooc abort pabt oxffffoo10 abort dabt oxoo000010 data reserved ox00000014 oxffffoo14 oxffffoo18 oxo0000018 interrupt irq request oxffffoolc interrupt oxoo00001c fast fiq request
34 chapter fundamentals 2 arm processor fast interrupt is similar the but reserved for hardware to interrupt is request vector request if requiring faster it only be raised fiqs masked in the times response can are not cpsr 25 core extensions standard the hardware covered in this section placed extensions the components next to are arm they performance and provide functionality improve manage resources extra core and designed provide handling flexibility in particular applications each arm family to are has different available extensions there three hardware extensions arm around the cache and tightly are wraps corer coupled and interface the management memory memory coprocessor 251 cache tightly coupled memory and the cache blockof fast placed between and the allows for is main it a memory memory core effcient fetches from with cache the some types processor more memory a core can run of without for for the majority the time having wait data from slow external to memory armbased embedded most singlelevel cache internal the systems to use processor a of embedded small do the performance that systems require gains courses not many a brings cache forms of cache the first found attached the arm has is von neumannstyle two to combines both data and unifed cache shown it instruction into single in cores a as called figure 2 for simplicity have the logic that the 13 glue we connects memory system the amba bus logic and control to arm core unified cache logic and control main memory amba interface bus unit onchip amba bus figure 213 simplified architecture with von neumann cache a
35 core 25 5 extensions arm core logic and control instruction data tcm tcm main memory amba interface bus unit dti onchip amba bus figure 214 simplified harvard architecture tcms with a second form attached harvardstyle by the the has caches contrast separate to cores for data and instruction provides overall performance but the of predictable a cache increase in at an expense for that code deterministic execution but realtime it is execution is systems paramount the for loading and data predictable this time taken storing instructions be is must or achieved form of called tightly coupled tcm tcm fast sram using is memory a memory required fetch located close the and the clock cycles instructions guarantees to core to or data for algorithms deterministic critical realtime requiring behavior tcms appear as in the address and be accessed fast example ofa an can as memory memory map processor tcms with is shown in figure 25 14 combining both have both improved performance by technologies arm processors can and predictable realtime shows with combination figure 215 example responses an core a of caches and tcms 252 memory management embedded often devices multiple it is usually have systems to use memory necessary a method help these devices and from applications organize the trying to protect system to inappropriate hardware this achieved with the of make is assistance accesses to memory hardware management different have three oft hardware arm extensions types memory management cores no providing protection unit mpu providing limited protection protection memory no a and providing unit mmu full protection memory management a nonprotected fixed and provides little flexibility for it normally used 1s is memory very embedded from small simple that require protection applications systems no rogue
36 chapter fundamentals 2 arm processor arm core logic and control d d data instruction data instruction cache cache tcm tcm d main memory amba bus interface unit dtl on chip amba bus figure 215 simplified harvard architecture and tcms with caches a that limited number of these mpus employ simple regions system memory a uses a controlled with of special and regions registers each region is set are a coprocessor defined with specific this of permissions used management is access type memory for don that require protection but t have complex systems memory a memory map the mpu explained chapter is in 13 mmus the comprehensive hardware available the most management memory are on of tables provide grained arm the mmu translation ine control to uses set over a provide these tables stored in and virtualtophysical main memory are memory a address designed for well permissions mmus sophisti map as access are more as cated platform that explained operating multitasking the mmu is systems support in chapter 14 253 coprocessors attached extends coprocessors be the arm a the processing to can processor coprocessor features of extending the providing configuration by instruction by set a core or reg than be added the isters more arm via the to coprocessor one coprocessor can core interface the be accessed through of dedicated arm instructions coprocessor can a group that provide loadstore interface consider for the example 155 type coprocessor a arm 15 registers control the cache tcms and to processor uses coprocessor memory management extend providing the also the instruction by specialized coprocessor can set a group of specialized instructions for example there of instructions that set new are can a
37 architecture revisions 25 6 standard be added the arm instruction floatingpoint vfpy to set to vector process operations these processed decode of if instructions in the the arm pipeline the new are stage offers decode instruction then it the relevant it stage coprocessor to coprocessor sees a if but the doesn the then the arm 1s present t recognize instruction coprocessor not or undefined which behavior of takes instruction exception allows emulate the the to an you software in coprocessor 2 86 architecture revisions implementation specific instruction architecture isas every arm executes set processor a although isa revision have than implementation an may more one processor evolved with demands of embedded this the isa has keep the the market to up evolution has been carefully managed by that code written earlier arm to execute so on an of architecture revision will also later revision the architectures execute on a before of architecture introduce explain the evolution the the arm to must we on go we nomenclature the nomenclature identifes individual and provides processor processors information basic about the feature set 24 61 nomenclature the nomenclature shown figure describe the arm in 216 implemen to uses processor tations the letters and numbers after the word arm indicate the features a processor arinyzites family s protection managementl unit memory ys cache z l6bit decoder tathumb ditag debug m fast multiplier hembeddedice macrocell enhanced tdmi ee instructions assumes ajazelle floating point unit fvector srsynthesizible version figure 216 arm nomenclature
38 chapter fundamentals 2 arm processor combinations have in the future the number and letter features change more may may as added note the nomenclature does include the architecture revision information not are few additional there points make about the arm nomenclature to are a armttdmi include tdmi features all arm after the the though they cores even may include g arm label those letters after the not the family of that share is implementations the processor a group processor same hardware and arm720t characteristics for example the armttdmi arm740t all share the family characteristics and belong family the arm7 to same jtagi is described by ieee 11491 standard test and boundary archi access port scan send debug information lt is serial protocol used by arm and receive tecture to a and between the equipment test processor core embeddedice debug hardware macrocell is the built the that allows into processor and watchpoints breakpoints be to set synthesizable that supplied code that the is be means processor core as source can compiled form easily used eda tools into by a 25 62 architecture evolution architecture continued first the has evolve since the arm implementation to processor significant introduced in 1985 table 27 shows the architecture enhancements from was architecture architecture of the original version the version one the l to current 6 most significant changes the isa the introduction of the thumb armvat instruction to set in was the armtdmi processors of availabil table 28 sul the various the and the parts register program status c ity of features particular architectures allp refers certain instruction the armva to on architecture and above 2 7 arm processor families has designed number of that grouped different families according arm into a processors are the they the families based the armz armi armios and armi to core are uses on indicate different ascending the postfx numbers 7 10 and designs the 9 11 cores core number performance and sophistication developed increase in arms equates to an was but superseded was soon of attributes table 2 9 shows rough comparison between the arm7z armdi armios a and the numbers quoted and directly dependent armil greatly cores can vary are upon and of direct effect the the manufacturing which has the geometry type process a on frequency and mhzz consumption wattss power
39 arm families 27 processor table 27 history revision revision example implementation isa enhancement core arm first arm armvl processor 261 bit addressing armvz arm2 32bit multiplier 32bit coprocessor support armvza arm3 chip cache on atomic instruction swap for coprocessor 15 cache management and armtdi 32bit addressing armv3 arm6 separate and cpsr spsr modes undefned and abort new instruction mmu supportevirtual memory armvbm armzm signed and unsigned long multiply instructions and armva strongarm loadstore instructions for signed unsigned halfwordsibytes mode new system for architecturally defned reserve swi space operations 26bit addressing mode longer supported no armvat armttdmi and armt thumb armvste armie and armioe superset of the armvat extra instructions added for changing between state arm and thumb enhanced multiply instructions extra dsptype instructions faster multiply accumulate and acceleration armvstej armzej armiz6ej java armll improved multiprocessor armv6 instructions and mixed unaligned endian data handling new multimedia instructions of within each arm family there number variations of memory management are a and tcm cache arm expand both the number of extensions continues to processor different families available and the variations within each family find other that the arm isa such strongarm and you execute processors can as xscale these unique particular semiconductor this to processors are company in a case intel different features of table 25 10 summarizes the the various the processors next subsections describe families detail the arm starting with the arm7 family in more
40 chapter fundamentals 2 arm processor table 28 of description the cpsr architectures parts bits description mode all mode 40 processor t armvat thumb 5 state iex f 76 all interrupt masks j 24 armvstej jazelle state  27 armvste condition flag condition 28 all flag condition 29 all flag condition 30 all flag all condition flag 31 table 29 arm family attribute comparison armz arm9 armio armi pipeline depth threestage five eightstage stage six stage typical mhz s0 150 260 335 mwimhza mwimhz 19 mwimhz mwimhz mwimhz o 06 o 05 04 gt cache gt cachel gt cache mipsb imhz o 97 11 15 12 architecture harvard harvard von neumann harvard multiplier 8 32 32 16 16 32 8 32 x x x x a wattsimhz the 13 micron o on same process b mips dhrystone vax mips are 271 armz family the has neumannestyle architecture where both data and arm7 von instructions core a the bus the has threestage pipeline and the architecture armvat same core executes use a instruction set of the armttdmi the first of introduced 1995 by arm in a processors was new range embedded it popular and used 32bit 1s currently is in it core processors a very many provides good performancet ratios the armttdmi has tor power processor core a very licensed of semiconductor around world and been by the companies the top 1s many frst include the the thumb instruction fast multiply instruction and the core to set a embeddedice debug technology
41 arm families 27 processor table 25 10 arm variants processor cache jazelle thumb ea cpu mmuimpu isa core armttdmi vat none none yes no no armzejs vstej none none yes yes yes unifed arm720t mmu 8k cache vat no yes no armo20t mmu separatelek 116k dti vat no yes no cache armo22t mmu skisk dti vat separates no yes no cache armizgejs cache and mmu vstej separater yes yes yes tcms configurable arm94ot mpu akiak d ti vat separate no yes no cache armiages mpu cache and vste separate no yes yes confgurable tcms armigges tcms vste separate none yes no yes configurable 32k132k armiozoe mmu dti vste separate yes no yes cache armio22e 116k116k dti vste mmu separate no yes yes cache and cache and armiozbejs mmu vste separate yes yes yes mpu tcms configurable arml136js mmu cache and separate v6 yes yes yes confgurable tcms arml136jfs mmu cache and separate v6 yes yes yes confgurable tcms d provides enhanced multiply instructions and e extension saturation significant the one variation in arm7 family is the armttdmis the armztdmis has characteristics standard armztdmi but synthesizable the operating is also same as a arm720t the flexible member of includes is the arm family because it most an mmu the of the mmu the arm720t capable of handling the linux is presence means embedded includes unifed and microsoft platform operating the also systems processor a cache the table be relocated higher address sk by setting vector to can a a coprocessor 15 register another variation is the armzejs also synthesizable armtejs quite is processor different includes five pipeline and armvstej this since it instructions stage executes a of provides and version the arm7 is the that both java acceleration the enhanced only one without instructions but protection any memory
42 chapter fundamentals 2 arm processor 272 arms family the armo family announced of fiver pipeline in 1997 because its the armi stage was higher clock frequencies than the the armz family at extra stages processor can run performance of the redesigned improve the overall the has been system processor memory follow the harvard architecture which the data and d instruction ibuses to separates the frst the armi family the armi20t which includes in processor separate was a d cache and mmus this be used by requiring t l operating systems an processor can arm22t but half virtual is variation the armi20t with the di i support t memory on a cache sizer the includes cache and designed arm940t smaller d l mpu the armi40t is t an a for applications platform and that do require operating both armo20t not system a arm940t the architecture vat instructions execute the the armo family based the armoes this in is next were processors on core core synthesizable of the with the there version arm9 e extensions variations two core are d the armiages and the armigges both architecture vste they execute instructions embedded also the optional macrocell etms which allows developer support trace to a and data this instruction execution in real the when trace time 1s important on processor debugging applications with critical time segments includes of tcm and the armiages tcm cache and mpul the the caches sizes an configurable this designed for embedded is in control applications that are processor use deterministic does require real time in the armi66e have the mpu contrast not responses and cache extensions but does have configurable tcmse the latest the armi product line is the armi2gejs synthesizable in core processor announced in 20000 designed for portable enabled devices it is in small java such cores use 3g phones and personal digital assistants pdas the armizgejs the frst arm 1s as include bytecode the jazelle technology which accelerates java execution to processor core features confgurable tcms and caches with it mmu d i wait t state an zero or nonzero memories 273 armio family the announced designed for performance extends armio in 1999 it the arm9 was pipeline also floatingl which six it optional point vfp unit to stages supports vector an significantly adds seventh the armio pipeline the vfp increases floatingpoint stage to a performance and compliant with the ieee 7541985 floatingpoint standard is the armio2oe the first armioe like the armie is it to processor use an core includes the enhanced e has 32k caches optional instructions it d l vector separate f and 6abit for floatingpoint unit mmu the armiozoe also has dual bus interface an a performance increased this armioz6ejs is similar the armizgejs but with both mpu and mmu to very performance of flexibility of has the the armio with the armizgejs processor an
43 summary 2a 8 274 armi family 1 the arm1136js announced designed for high performance and in 20035 was power efficient applications armi 136js the first implementation to execute was processor architecture eights pipeline load armvg instructions it incorporates with stage separate an and arithmetic pipeliness included the in armv6 instructions single instruction store are multiple data simdy for media specifically designed extensions processing increase to performance video processing the 136jfs with the addition of the floatingl arml is armii36js point unit vector an for fast floating point operations 275 specialized processors codeveloped digital semiconductor and strongarm originally by exclusively 1s was now licensed by intel corporation it has been popular for pdas and applications that is require performance with low consumption harvard architecture with dti it is separate power a first highperformance include caches strongarm the arm fvestage to was processor a pipeline but does thumb it the instruction not support set intels xscale followon product the strongarm and offers dramatic is increases in s to a performance of quoted being able at the time writing xscale ghz to to l was as run up xscale architecture vste harvard architecture and similar instructions it is is executes a the strongarm also includes mmu it to as an of designed specifically scioo the other end the performance lt 1s is at spectrum for low frst and based security applications the scioo is the securcore is power on armttdmi with mpu this is small and has low voltage and core an core current an which for card requirements makes it attractive applications smart 2 8 summary this chapter focused the hardware fundamentals of the arm in actual we on processor the arm be abstracted eight alu barrel shifter mac into processor components can fle decoder address and register instruction extend register incrementer sign has three instruction arm thumb and jazelles the fle arm register contains sets registers but accessible point the 37 only 17 18 registers in timer are at rest or any are stored banked according mode the mode is the lt to current in processor processor cpsr holds the of the condition well interrupt masks flags and current status processor core as determines which being executed the instruction is state state set surrounding that interface an arm comprises plus the it components processor core a with bus the include following extensions the a core caches used the performances improve overall to system are tcms deterministic used improve realtime to are response
44 chapter fundamentals 2 arm processor memory used and organize management 1s to memory protect system resources used extend coprocessors the instruction and functionality coprocessor to are set and 15 controls the cache tcms management memory ofa specific architecture an arm is implementation instruction isal set processor an the isa improved from first design has been continuously the arm processors processor grouped implementation families armz armo and armil with into armio are similar characteristics
this page intentionally left blank
35 l data processing instructions move instructions 8ll 312 barrel shifter 13 arithmetic instructions 3 shifter 314 using the barrel with arithmetic instructions 315 logical instructions instructions 316 comparison 317 multiply instructions 32 branch instructions 33 loadstore instructions singleregister transfer 33 l addressing 332 singleregister load store modes multipleregister transfer 333 swap instruction 35 34 3a software interrupt instruction 35 program status register instructions 351 coprocessor instructions 35 52 coprocessor 15 instruction syntax 36 constants loading 37 armvse extensions 371 count leading zeros instruction saturated arithmetic 372 373 armvse multiply instructions 38 conditional execution 3 9 summary
cnatee 3 introduction arm to the set instruction infors this introduction the arm instruction fundamental chapter the to set is since a presented used of mation here throughout the the book consequentlys it 1s 1s rest placed before depth and efficient here going into optimization algo start we any on rithms this chapter introduces the and useful arm and builds instructions most common the arm fundamentals covered the last chapter chapter introduces in f processor on the thumb and appendix description of instruction gives complete all arm set a d instructions different different arm architecture revisions instructions however support new add and backwardly compatible code for revisions usually instructions remain write you architecture should table provides armvat armvste 31 execute on an processor a list of available architecture complete arm instructions in the armve instruction set isa this includes oft features isa all the arm instructions well the core as as some newer the the arm isa column lists isa which in arm instruction the revision the set in introduced some instructions have extended functionality later archi instruction in was for cdp called example the instruction has armvs cdpz similarly tectures variant an ldr armvs additions do extended instructions such have but require not as a new or mnemonic and postconditions we illustrate the operations using examples with processor pre describing and before and after registers the instruction instructions memory or are 47
48 chapter introduction the instruction set 3 arm to table 35 1 arm instruction set arm isa description mnemonics adc add 32bit and values vl two carry add 32bit add values vl two bitwise of 32bit and logical and values vl two branch relative b vl fie 32 mb bic logical bit cand not of 32bit values vl clear two bkpt breakpoint instructions v5 link bl relative branch with vl blx branch with link and exchange v5 bx vat branch with exchange cdp data cdpz processing operation vz v5 coprocessor clz leading v5 count zeros cmn 32bit values negative vl two compare cmp 32bit values vl two compare eor logical exclusive of 32bit or values vl two ldcz ldc load single multiple 32bit values v2 v5 to coprocessor or 32bit from ldm load multiple words arm registers to vl memory ldr load from address vse single value virtual in vl va a memory a mcrr mcr mcrz vse from arm v2 v5 to register registers coprocessor move an or mla 32bit multiply and accumulate values vz mov 32bit value into register vl move a a mrc mrcz mrrc vse from v2 v5 arm register registers to move or a coprocessor mrs from v3 arm register register to status cpsr spsr move or a msr from v3 register cpsr arm register to status move a or spsr an mul multiply 32bit v2 values two of 32bit mvn the logical not value into register vl move a bitwise of orr logical or 32bit values vl two preload pld hint instruction vse qadd signed saturated add vse 32bit qdadd signed saturated double and 32bit add vse qdsub signed saturated double and 32bit subtract vse qsub signed saturated 32bit subtract vse rsb subtract of 32bit values vl two reverse rsc subtract with of 32bit integers vl two reverse carry sbc subtract with of 32bit values vl carry two smlaxy signed 916 32bit vse multiply accumulate instructions 16 32 t x e smlal signed multiply long 6abitl v3m accumulate 32 322 64 t x e signed smlalxy vse multiply accumulate long 16 16 6abit 64 x t e smlawy signed 632 32bitl vse multiply accumulate instruction 16 16 32 t x  e smull signed multiply long 32 6abitl v3m 32 x e continued
49 chapter introduction the arm set 3 instruction to table 31 arm instruction continued set mnemonics arm isa description smulxy signed multiply 16 32bit v5e instructions 16 x  smulwy signed multiply instruction 32 32bit vse 16 16 x t e stc stcz 32bit single multiple values from v2 v5 to store memory or coprocessor stm 32bit multiple registers vl store to memory address str vse virtual vl v4 register to in store memory a sub subtract 32bit values v two swi software interrupt swp wordlbyte with without v2a in register interruption swap a memory a teq for of 32bit values equality v test two tst for bits 32bit in value test a umlal unsigned multiply accumulate long 62 322 gabitl vbm 64 x t se umull unsigned multiply long 32 32 6abit vbm x e executed hexadecimal numbers prefix and we will with the ox binary numbers represent with prefix ob the follow this formats the examples sprecondi tionss pre sinst tructionl sz post tecondi tionss spos the and postconditions denoted in is prer memory as memsdat laddress tasizes this refers data bits of the byte address size starting for example to memory at given mem32110241 32bit address is the value starting kb at l held and with load and arm instructions data in registers only process access memory instructions arm take three operands instructions commonly for instance store two or adds the add instruction below the values stored registers and the in rl r2 two source destination registersy it writes the result register r3 the registery to instruction destination source source syntax register rdj register rn register 2 rm l add r35 r2 rl8 r3 r2 rl following function and of in the sections examine the the arm we syntax instructions by instruction class data processing instructions branch instructions
50 chapter introduction the instruction set 3 arm to loadstore instructions software interrupt and instruction register program status instructions 3 1 data processing instructions data within the data processing instructions manipulate registers they instruc are move and tions arithmetic instructions logical instructions comparison instructions multiply data of their operands instructions most processing instructions using the can process one barrel shifter if s suffx data then updates flags the processing instruction it the the in you use on a and logical update the flag negative and flag move operations c flag n z cpsr carry zero shift the flag from the result of the barrel the last bit shifted the nflag is set out carry as if bit 31 of the result the z flag is the result is to set is set zeros 3 11 move instructions move is the simplest arm instruction it n into destination rd where copies register a this nis immediate value instruction is useful for setting initial values and register or a transferring data between registers nstructionat scondal isj syntaxi si rds n mov move 32bit value into rdan register a a of the 32bit rd mvn the not value into register lon move a table 335 be presented in section 312 full description of the values allowed to gives a for the second operand for data n all processing instructions usually it is register rm a or preceded by f constant a this example shows simple instruction the mov takes of instruction the example contents a move 31 and them this taking the value and overwriting register r5 copies into register rz in 5 case the value 8 in register rz pre r5 5 s r7 8 e mov r5 let r5 rl4 r7 s post r5 5 e 5 r7 e
51 321 data processing instructions 3 12 barrel shifter showed mov in example 311 instruction where n is simple register but n be we a a can than immediate values also be has just register it register rm that been more a or can a preprocessed shifter used data by the barrel prior being by processing instruction to a processed within arithmetic aluy data processing instructions the logic unit are of unique and powerful feature the arm the ability shift the 32bit binary a is processor to of specific of in the left right by number positions before pattern registers one source or a this shift and flexibility of it the alu increases the data processing enters power many operations there data that do the shift for processing instructions barrel example not are use the mul clz leading and qadd signed saturated add multiplys count 32bit zeross instructions within shift the cycle oft the instruction this particularly pre processing time is occurs or useful for loading and achieving fast multiplies division into register by constants a or of 2 a power  s rn rm barrel shifter s result n 0 arithmetic logic unit rd figure 31 barrel shifter and alu to illustrate the barrel shifter will the example figure and add shift take in 311 we a operation the instruction example register the alu without to rn move enters any pre of and processing registers figure 31 shows the data flow between the alu the barrel shifter shift lsli before destination we apply logical left rm moving the to register it to register example a 32 this standard shift is the applying the c language the register the same as operator r to mov instruction the shift result n rd the result copies operator into register n represents lsl described of the operation in table 32 pre r5 5 s r7 8 ee
52 chapter introduction the instruction set 3 arm to r5 mov r5 lsl f2 let r7 r544 ss2 rlz s s post r5 5 r7 20 s the multiplies four and then example register r5 by places the result into r7 register the fve different shift that within shifter operations the barrel you can use are summarized table in 322 logical shift left of bit figure 32 illustrates by for example the d contents a one are shifted bit bit cleared the flag updated with the last bit shifted of 1 o is c is the to out register this is bit 32 of the original value where yis the shift when y amount yis es shift than then shift by ypositions is the by position executed greater one a same a one as times y table 32 shifter barrel operations mnemonic shift shift description result amount y lsl logical shift left xlsly f031 rs xky or lsr logical shift right xlsry unsignedixzy f152 rs or shift asr arithmetic right xasr signedixhy f132 rs y or xror cunsignedixi yixk32 ror right rotate fl31 rs y t tyd or right extended xrrx cunsignedxh rrx flag 311 l rotate c k none the being shifted and shift noter register the represents represents amount x y bit bit bit 31 2 1 o ox8o000004 nzcv condition bags 31 oo nzcv oxoo000008  condition bags condition flags updated when s is present figure 32 logical shift left by one
53 35 data processing instructions l table 33 barrel shift for data instructions operation processing syntax n shift syntax operations immediate fimmediate register rm shift logical left by immediate rms lsl fshi ft imm logical shift left by lsl register rmg rs logical shift right by immediate lsr fshi ft rms imm logical shift right with rma lsr register rs shift hshi ft arithmetic right by immediate rmy asr imm arithmetic shift right by rms asr register rs fshift right by immediate rma ror rotate imm rotate right by register rmy ror rs right with extend rotate rma rrx movs this of shifts left by bit this multiplies example instruction register rl register example a one 33 21 the flag updated s suffix by value as c in the because the rl is 1s you can see a cpsr in the instruction mnemonic present nzcvift pre user cpsr s oxo0000000 ro rl ox80000004 movs lsl ro rl fl nzcvoift post user cpsr oxoo000008 ro ox80000004 rl s table lists for different shift available data 33 the the barrel operations syntax on processing instructions the second operand n be immediate preceded by can constant an of shift value the value processed bya f register rm rm a or 3 13 arithmetic instructions arithmetic addition and subtraction of 32bit the instructions implement signed and unsigned values
54 chapter introduction the instruction set 3 arm to sinstructionsiconds fsj syntaxi rd rns n adc add bit values and rds rntnt 32 two carry carry add add 32 bit values rdarntn two of 32bit rsb subtract values rdanrn two reverse rsc subtract with of 32bit rdenernaicarry flagl values carry two reverse sbc subtract of 32bit rneneicarry flagl with values rd two carry e sub subtract 32bit values rde rnen two of shifter of nis the result the operation the shifter operation shown table 33 is in syntax subtract this simple instruction subtracts value stored from value stored in register r2 example a a 34 stored in register the result in ro rl 1s register oxoo000000 pre ro s oxo0000002 rl e r2 ox00000001 sub ro r1 r2 oxo0000001 post ro s this subtract instruction rsbi subtracts from the value fo writing the rl example reverse constant 35 result you this instruction numbers to ro to can use negate oxoo000000 pre ro ox00000077 rl rsb ros fo rd oxo rl rl e oxffffffs9 post ro rl s s the subs instruction useful for decrementing loop this subtract is in example example counters we 36 the immediate value from the value stored in the value register rl result is one one zero written register the updated with the zc flags being rl is to cpsr set nzcvqift user pre cpsr e oxo0000001 rl e subs rl rl fl
55 3 data processing instructions l post nzcvqift user cpsr oxoo000000 rl s 3 14 using barrel shifter arithmetic the with instructions the wide of second operand shifts available arithmetic and logical instructions range on powerful feature of the arm illustrates the of is instruction example 37 set very use d shifter the inline barrel with arithmetic instruction the instruction multiplies the value an stored in register by three rl first shifted location the left of add register is the value twice the example rl one to to give rl 3 7 instruction then adds the result of the barrel shift the final result operation register rl to transferred into equal three the stored register ro is times value in register rl to pre oxoo000000 ro oxo0000005 rl e add lsl fl roo rl rl4 post oxoo00ooof ro oxo0000005 rl s 15 35 logical instructions perform bitwise logical instructions logical operations the registers two source on scondal fsj syntaxi sinstruct ionat rds rns n and logical bitwise and of 32bit values rd rnen two s orr logical bitwise of 32bit values rd or rnin two e eor logical of ernan exclusive or 32bit values rd two bic logical bit and not rd clear rnen ee this example shows logical or operation between and holds the result registers rl r2 ro example a 38 pre oxoo000000 ro ox02040608 rl 0x10305070 r2 s
56 chapter introduction the instruction set 3 arm to orr ros r2 rl 0x12345678 post ro complicated called this example shows logical instruction bic which carries example out a more 39 logical bit clear a pre rl 0b1111 t 0b0101 r2 bic r2 ro rl post 0b1010 ro this is equivalent to not inj rd rn and this binary binary in example register r2 contains where r2 clears pattern l in a every corresponding bit location this particularly useful in register instruction is when rl a clearing bits and frequently used change the is interrupt masks in status to cpsr the logical instructions update the flags if the s suffx these only is present cpsr barrelshifted instructions second operands the the arithmetic in can use same way as instructions 316 comparison instructions the used with 32bit comparison instructions register value to test are compare or a a they update the flag bits according the but do affect other result registers to not cpsr after the bits have been the information then be used change flow by to set can program conditional execution information conditional look using for execution take more on a section you do need the s suffx for comparison update 38 apply instructions at not to to the flagss tructionzt scondss syntaxi sins rns n cmn negated flags of rntn result compare set as a cmp flags of result rnan set compare as a nn of 32bit teq for equality values flags result of two rn test set as a tst bits ofa 32bit flags of value result rnen test set as a
57 3 data processing instructions l n the result of the shifter the of shifter shown is operation operation is syntax in table 33 this example shows cmp comparison instruction you that both registers and ro example can see a 35 10 before the of the flag r9 equal executing the instruction value prior execution is o to are z and represented by lowercase after the flag changes is execution l to uppercase a ze z or an indicates z this change equality nzcvqift user pre cpsr e ro 4 rg 4 s cmp ro rg post nzcvqift user cpsr s the effectively discarded cmp is subtract instruction with the result similarly the tst a and teq instruction is logical and operation logical exclusive or operation for 1s a a each the results discarded but the condition bits updated in the it is important are are cpsr understand modify condition of that comparison instructions only the flags the and to cpsr do affect being compared the registers not 3 17 multiply instructions the multiply multiply the ofa of and depending instructions pair registers contents upon the instruction accumulate the results with another the long multiplies in register accu of 6abit the final result placed mulate pair registers representing values onto is in a a destination of register pair registers a or a syntaxs mla t scondsl fsj rds rms rss rn mulf scondss fsj rds rms rs mla multiply and rd rmk accumulate rs rn t  rmx mul multiply rd rs e sj syntaxi instructionseconds rdlos rdhi rms rs smlal signed rdhi f multiply accumulate long rdhi rdlol rdlol rm rs e smull signed  multiply long rdhi rdlol rm rs umlal unsigned multiply accumulate irdhi rdlol irdhi rdlol rm rs l long umull unsigned multiply long rdhi rdlol rm rs ee
58 chapter introduction the instruction set 3 arm to the number of cycles taken multiply depends the execute instruction to a on processor implementation for implementations the cycle timing also depends the value some on details appendix in rs for cycle timings ds more on see this example shows simple multiply instruction that multiplies and registers rl r2 together example a 38 11 and places the result into this the and register ro in example register rl is equal value 2 to r2 is equal 2 the result then placed into register is ro to 44 pre oxoo000000 ro oxo000000 rl oxo0000002 r2 rlr mul roo rl r2 ro s post ro oxo0000004 oxoo000002 rl oxo0000002 r2 the long smlal smull umlal and umullyi produce 6abit multiply instructions a result fit 32bit placed the result is large single register the result is too to in a so two labeled rdlo and rdhi rdlo holds the lower 32 bits of the 641 bit result and registers of ofa rdhi holds the higher 32 bits the 6abit result example 312 shows example long an unsigned multiply instruction the instruction multiplies and and the and registers r2 r3 places result into register ro example rl 312 the lower 32 bits and the higher bits of the register ro contains register rl contains 32 6abit result oxoo000000 pre ro oxoo000000 rl oxfoo00002 r2 r3 oxoo000002 s umull r3 lrl roj r2r3 ro rl4 r2z post oxe0000004 rdlo ro oxoo000001 rl rdhi s 32 branch instructions flow of a branch instruction changes the execution is used call routine this to or type a of subroutines ifthenelse and instruction allows have loopse to structuress programs
